Раздел 1. MVC - архитектурный каркас

Model-view-controller (MVC, «модель-представление-поведение», «модель-представление контроллер», «модель-вид-контроллер») — схема использования нескольких шаблонов проектирования, с помощью которых модель данных приложения,пользовательский интерфейс и взаимодействие с пользователем разделены на три отдельных компонента так, что модификация одного из компонентов оказывает минимальное воздействие на остальные.
Данная схема проектирования используется для построения архитектурного каркаса, когда переходят от теории к реализации в конкретной предметной области.

В оригинальной концепции была описана сама идея и роль каждого из элементов: модели, представления и контроллера. Но связи между ними были описаны без конкретизации.
Кроме того, различали две основные модификации:

Пассивная модель — модель не имеет никаких способов воздействовать на представление или контроллер, и используется ими в качестве источника данных для отображения. Все изменения модели отслеживаются контроллером и он же отвечает за перерисовку представления, если это необходимо.Такая модель чаще используется в структурном программировании, так как в этом случае модель представляет просто структуру данных, без методов их обрабатывающих.

Активная модель — модель оповещает представление о том, что в ней произошли изменения, а представления,которые заинтересованы в оповещении, подписываются на эти сообщения.
Это позволяет сохранить независимость модели как от контроллера, так и от представления.

Классической реализацией концепции MVC принято считать версию именно с активной моделью.

С развитием объектно-ориентированного программирования и понятия о шаблонах проектирования был создан ряд модификаций концепции MVC, которые при реализации у разных авторов могут отличаться от оригинальной.

Основная цель применения этой концепции состоит в разделении бизнес-логики (модели) от её визуализации - представления, вида.За счет такого разделения повышается возможность повторного использования. Наиболее полезно применение данной концепции в тех случаях, когда пользователь должен видеть те же самые данные одновременно в различных контекстах и/или с различных точек зрения. В частности, выполняются следующие задачи:

1. К одной модели можно присоединить несколько видов, при этом не затрагивая реализацию модели. Например, некоторые данные могут быть одновременно представлены в виде электронной таблицы, гистограммы и круговой диаграммы.

2. Не затрагивая реализацию видов, можно изменить реакции на действия пользователя (нажатие мышью на кнопке, ввод данных), для этого достаточно использовать другой контроллер.

3. Ряд разработчиков специализируется только в одной из областей: либо разрабатывают графический интерфейс, либо разрабатывают бизнес-логику. Поэтому возможно добиться того, что программисты, занимающиеся разработкой изнес-логики (модели), вообще не будут осведомлены о том, какое представление будет использоваться.

Концепция MVC позволяет разделить данные, представление и обработку действий пользователя на три отдельных компонента:

Модель (англ. Model). Модель предоставляет знания: данные и методы работы с этими данными, реагирует на запросы, изменяя своё состояние. Не содержит информации, как эти знания можно визуализировать.

Представление, вид (англ. View). Отвечает за отображение информации визуализацию.
Часто в качестве представления выступает форма (окно) с графическими элементами.

Контроллер (англ. Controller). Обеспечивает связь между пользователем и системой: контролирует ввод данных пользователем и использует модель и представление для реализации необходимой реакции.

Важно отметить, что как представление, так и контроллер зависят от модели.

Однако модель не зависит ни от представления, ни от контроллера. Тем самым достигается назначение такого разделения: оно позволяет строить модель независимо от визуального представления, а также создавать несколько различных представлений для одной модели.

Особенно в веб-программировании, где аббревиатура MVC стала популярна) очень часто трактуют архитектурную модель MVC как пассивную модель MVC. В этом случае модель выступает исключительно совокупностью функций для доступа к данным, а контроллер содержит бизнес-логику. В результате код моделей по факту является средством получения данных из СУБД, а контроллер представляет собой типичный модуль, наполненный бизнес-логикой, или скрипт в терминологии веб-программирования.

В результате такого понимания MVC разработчики стали писать код, который Pádraic Brady, известный в кругах сообщества Zend Framework, охарактеризовал как ТТУК —
«Толстые тупые уродливые контроллеры» (Fat Stupid Ugly Controllers).

Среднестатистический ТТУК получал данные из БД (используя уровень абстракции базы данных, делая вид, что это модель) или манипулировал, проверял, записывал, а также передавал данные в вид.
Такой подход стал очень популярен потому, что использование таких контроллеров похоже на классическую практику использования отдельного php-файла для каждой страницы приложения.
Но в объектно-ориентированном программировании используется активная модель MVC,
где модель — это не только совокупность кода доступа к данным и СУБД, а вся бизнес-логика. В свою очередь, контроллеры представляют собой лишь элементы системы, в чьи непосредственные обязанности входит приём данных из запроса и передача их другим элементам системы. Только в этом случае контроллер становится «тонким» и выполняет исключительно функцию связующего звена (glue layer) между отдельными компонентами системы.

Основными компонентами приложений являются:

	1. модель (model)
	2. представление (view)
	3. контроллер (controller).

использует REST-стиль построения веб-приложений.

Модель:
Модель предоставляет остальным компонентам приложения объектно-ориентированное отображение данных (таких как каталог продуктов или список заказов). Объекты модели могут осуществлять загрузку и сохранение данных в реляционной базе данных, а также реализуют бизнес-логику.

Представление:
Представление создает пользовательский интерфейс с использованием полученных от контроллера данных. Представление также передает запросы пользователя на манипуляцию данными в контроллер (как правило не изменяет непосредственно модель).

Контроллер:
Контроллер — это набор логики, запускаемой после получения HTTP-запроса сервером.
Отвечает за вызов методов модели и запускает формирование представления.

Суть схемы MVC в разделении трёх основных элементов любого приложения с пользовательским интерфейсом:

 * Model      — Модель — Бизнес модель или объект предметной области
 * View       — Представление — Элементы пользовательского интерфейса
 * Controller — Контроллер — Отслеживание событий пользовательского интерфейса

REST - передача состояния представления,стиль построения архитектуры распределенного приложения.
Данные в REST должны передаваться в виде небольшого количества стандартных форматов (HTML, XML, JSON). Сетевой протокол (как и HTTP) должен поддерживать кэширование, не должен зависеть от сетевого слоя, не должен сохранять информацию
о состоянии между парами «запрос-ответ».Такой подход обеспечивает масштабируемость системы и позволяет ей эволюционировать с новыми требованиями.


 Раздел 2 - Coffeescrript

CoffeeScript — язык программирования, транслируемый в JavaScript, в духе Ruby, Python, Erlang для того, чтобы улучшить читаемость кода и уменьшить его размер.
В среднем для выполнения одинаковых действий на CoffeeScript требуется в 2 раза меньше строк, чем JavaScript. JavaScript код, который скомпилируется из CoffeeScript полностью проходит проверку JavaScript Lint.


 Раздел 3 – Краткий обзор angular, backbone, ember

Angular является JavaScript-фреймворком с открытым исходным кодом, разрабатываемым Google. Предназначен для разработки одностраничных приложений. Его цель — расширение браузерных приложений на основе MVC шаблона, а также упрощение тестирования и разработки.

Фреймворк работает с HTML, содержащим дополнительные пользовательские атрибуты,
которые описываются директивами, и связывает ввод или вывод области страницы с моделью, представляющей собой обычные переменные JavaScript. Значения этих переменных задаются вручную или извлекаются из статических или динамических JSON-данных.

AngularJS спроектирован с убеждением, что декларативное программирование лучше всего подходит для построения пользовательских интерфейсов и описания программных компонентов, в то время как императивное программирование отлично подходит для описания бизнес-логики.
Фреймворк адаптирует и расширяет традиционный HTML, чтобы обеспечить двустороннюю привязку данных для динамического контента, что позволяет автоматически синхронизировать модель и представление. В результате AngularJS уменьшает роль DOM-манипуляций и улучшает тестируемость.

Цели разработки:

1. Отделение DOM-манипуляции от логики приложения, что улучшает
   тестируемость кода.
2. Отношение к тестированию как к важной части разработки.
   Сложность тестирования напрямую зависит от структурированности кода.
3. Разделение клиентской и серверной стороны, что позволяет вести
   разработку параллельно.
4. Проведение разработчика через весь путь создания приложения: от проектирования
   пользовательского интерфейса, через написание бизнес-логики, к тестированию.

Angular придерживается MVC-шаблона проектирования и поощряет слабую связь между представлением, данными и логикой компонентов. Используя внедрение зависимости, Angular переносит на клиентскую сторону такие классические серверные службы, как видозависимые контроллеры. Следовательно, уменьшается нагрузка на сервер и веб-приложение становится легче.

С помощью директив AngularJS можно создавать пользовательские HTML-теги, чтобы добавить поведение некоторым элементам.

ng-app
Объявляет элемент корневым для приложения и может быть изменен с помощью пользовательских HTML-тегов.
ng-bind
Автоматически заменяет текст HTML-элемента на значение данного выражения.
ng-model
Как и ng-bind, но обеспечивает двустороннее связывание данных между представлением и областью видимости.
ng-class
Определяет классы для динамической загрузки.
ng-controller
Определяет JavaScript-контроллер для вычисления HTML-выражений.
ng-repeat
Создает экземпляр для каждого элемента из коллекции.
ng-show и ng-hide
Показывает или скрывает элемент в зависимости от значения логического выражения.
ng-switch
Создает экземпляр шаблона из множества вариантов, в зависимости от значения выражения.
ng-view
базовая директива, отвечает за обработку маршрутов, которые принимают JSON перед отображением шаблонов, управляемых указанными контроллерами.

Двустороннее связывание данных в AngularJS является наиболее примечательной особенностью и уменьшает количество кода, освобождая сервер от работы с шаблонами. Вместо этого, шаблоны отображаются как обычный HTML, наполненный данными, содержащимися в области видимости, определенной в модели.
Сервис scope в Angular следит за изменениями в модели и изменяет раздел HTML-выражения в представлении через контроллер. Кроме того, любые изменения в представлении отражаются в модели. Это позволяет обойти необходимость манипулирования DOM и облегчает инициализацию и прототипирование веб-приложений.



Backbone:
Backbone придает структуру веб-приложениям с помощью моделей с биндингами по ключу и пользовательскими событиями, коллекций с богатым набором методов с перечислимыми сущностями, представлений с декларативной обработкой событий и соединяет это все с вашим существующим REST-овым JSON API. При работе с веб-приложением, которое включает в себя много JavaScript, вы перестаните связывать ваши данные с DOM,
потому что это подходит только для создания простых JavaScript приложений, которые в конечном итоге выглядят, как запутанные груды jQuery-селекторов и коллбэков, которые отчаянно пытаются хранить актуализированные данные в UI, JavaScript логике и базе данных на сервере.
Для сложных клиентских приложений часто бывает полезным более структурированный подход. Работая с Backbone, вы представляете ваши данные как Модели (Models), которые могут быть созданы, провалидированы, удалены, и сохранены на сервере. Всякий раз, когда в интерфейсе изменяется атрибуты модели, модель вызывает событие
"change"; все Представления (Views), которые отображают состояние модели, могут быть уведомлены об изменении атрибутов модели, с тем чтобы они могли отреагировать соответствующим образом — например, перерисовать себя с учетом новых данных.
В готовом приложении на Backbone, вы не должны писать код, ищущий элемент с определенным id в DOM и обновлять HTML вручную. При изменении модели представление просто обновит себя самостоятельно.

Ember:

В наши дни сложные Javascript-приложения можно увидеть повсюду. Со временем они становятся все сложнее и уже неприемлемо просто писать цепочку callback-функций
на jQuery. Такие MVC-фреймворки на Javascript, как Backbone, Angular и Ember
появились для того, чтобы заполнить пустоту между начинающими, средними и опытными разработчиками. Они предлагают разные возможности и функционал, который подойдет разным людям, в зависимости от их потребностей.

В прошлом, веб-разработчики добавили обработчиков событий для отдельных элементов для того, чтобы знать, когда пользователь взаимодействует с ними. Например, у вас может быть <div> элемент, на котором вы регистрируете функцию, которая вызывается, когда пользователь нажимает на него.Однако такой подход часто плохо масштабируется при работе с большим количеством интерактивных элементов. Например, представьте, <ul> со 100 <li> в нем, и кнопкой удаления, расположенный рядом с каждым пунктом.
Поскольку поведение одинаковое, для всех этих элементов, было бы неэффективно создать 100 слушателей событий, по одному для каждой кнопки удаления. Чтобы решить эту проблему, разработчики открыли технику, называемую "делегирование событий".
Вместо регистрации слушателей на каждый элемент, вы можете зарегистрировать одного слушателя содержащего эти элементы и использовать event.target чтобы определить, какой элемент пользователь щелкнул. Другие фреймворки JavaScript решают эту проблему одним из двух способов. В рамках первого подхода, они просят вас осуществлять решение самостоятельно, создав отдельное представление для каждого элемента. Когда вы создаете виды, он устанавливает слушателя события на элемент представления. Если у вас есть список из 500 наименований, можно создать 500
видов и для каждого из них будет создан слушатель. Во втором подходе, фреймворк строит событие делегации на уровне представления. При создании вида, вы можете предоставить список событий для делегирования и метод, который вызывается при возникновении события. Это определяет контекст клика (например, какой элемент в списке) метода получения события. Теперь мы столкнулись с неудобным выбором: создать новое представление по каждому пункту и потерять преимущества события делегации,или создать единое представление для всех элементов и хранить информацию об основных объектах JavaScript в DOM.

Для того, чтобы решить эту проблему, Ember делегирует все события в корневой элемент приложения
(как правило, тело документа body) с помощью JQuery. При возникновении события, Ember определяет
ближайший вид, который обрабатывает событие и вызывает его обработчик событий. Это означает, что
вы можете создавать представления с контекстом JavaScript, но все же получить выгоду события делегации.

Кроме того, поскольку Ember регистрирует только одно событие для всего приложения Ember, создавая новые виды
никогда не требует настройки слушателей событий, что делает обновление эффективнее и менее подверженным ошибкам. Когда взгляд не имеет дочерних видов, это также означает, что нет необходимости вручную анделегировать виды, повторное процесса рендеринга заменяет. На данный момент существует огромное множество JavaScript библиотек, предназначенных для манипулирования DOM-ом. Однако когда речь заходит
о необходимости построения одно-страничного приложения, многие фрэймворки падают.

Такие библиотеки, как jQuery не то чтобы не могут быть использованы для построения сложных одно-страничных приложений. Просто-напросто они создавались для других целей и могут управлять состояниями интерфейсами и маршрутами только с помощью специальных плагинов. Это не самое лучшее решение. Для решения задачи нужно пользоваться подходящими для этого инструментами.

Ember - это то, что нужно, если речь идёт о сложных одно-страничных приложениях.
С его помощью, можно не усложняя себе жизнь, создавать сложные приложения.
В его основу разработчики заложили возможность работы по принципу MVC. Ember - это фрэймворк для создания нетрадиционных сайтов. Такие фрэймворки, как jQuery и Mootools, больше подходят для классических сайтов. Приложения, создаваемые на основе Ember, больше похожи на настольные приложения. Ember использует MVC в качестве системы распределения кода. В Ember очень часто используются шаблоны, которые работают на базе библиотеки Handlebars. С её помощью мы можем писать шаблоны для генерации динамического HTML кода. Средствами Ember.js передаються в шаблон данные. Пример шаблона вывода пользователей в ненумерованном списке:

<ul>
 {{#each people}}
   <li>Hello, {{name}}!</li>
 {{/each}}
</ul>

слово #each означает обычный цикл, в котором будут прокручиваться записи и переменной people. Выражениями типа {{name}}, мы будем извлекать нужную информацию. Более сложные примеры, мы разберём позже. Handlebars - это действительно хороший шаблонизатор, который может использоваться отдельно от Ember. Ember предоставляет несколько ключевых возможностей, которые кажутся
очень привлекательными, главной из которых привязка данных. Вы просто создаете переменную, и, когда значение этой переменной изменяется, обновляется любая
часть вашего приложения, которая следит за этой переменной. Это нашло бы свое применение, например, в чатах и т. д.

Ember построен на архитектуре MVC (Model-View-Controller) и вы просто должны разделять свой код на 3 части:

M => Модель – похожа на массив. Здесь хранятся данные, которые будут использоваться вашим приложением.
V => Представление – это визуальная часть вашего приложения — формы, списки и т.д.
C => Контроллер – думайте о контроллере, как о регулировщике движения. Он управляет взаимодействием между другими частями приложения. Когда пользователь нажимает на кнопку, контроллер определяет, какое представление должно быть загружено, которое в свою очередь определяет, какую модель использовать для сохранения данных. Наиболее характерно  особенностью  которая разделяет библиотеки является способ синхронизации модели и представления. В то время как AngularJS поддерживает двухстроннее связывание данных, Backbone чтобы связать модель и представление в значительной мере опирается на шаблонный код. Backbone прекрасно поддерживает REST, в то время как сервис http в Angular более гибок и подключается к удаленным серверам либо с помощью браузерного объекта XMLHttpRequest или через JSONP. В качестве шаблона AngularJS использует комбинацию настраиваемых HTML-тегов и выражений. Backbone использует различные шаблонизаторы, такие как Underscore.


Сылки на документацию и исходный код:

Глава 1 - MVC:
http://ru.wikipedia.org/wiki/Model-View-Controller
http://habrahabr.ru/post/147038/
http://jnet.kz/blog/3132.html
http://stackoverflow.com/questions/4581000/what-are-the-differences-between-presenter-presentation-model-viewmodel-and-co

Глава 2 - Coffeescript
http://coffeescript.org/
http://ru.wikipedia.org/wiki/CoffeeScript
http://habrahabr.ru/post/79586/

Глава 3 - Angular-Backbone-Ember
http://bigballmud.blogspot.com/
http://coding.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/
https://developer.motorolasolutions.com/community/rhomobile-suite/rhomobile-community/rhomobile-blogs/blog/2013/11/11/considerations-when-selecting-a-js-mvc-framework

AngularJS:
http://ru.wikipedia.org/wiki/AngularJS
http://angular.ru/api/
http://habrahabr.ru/post/142590/
http://stepansuvorov.com/blog/2012/12/с-чего-начать-изучение-angularjs/

BackboneJS:
http://en.wikipedia.org/wiki/Backbone.js
http://backbonejs.ru/
https://github.com/addyosmani/backbone-fundamentals
http://addyosmani.github.io/backbone-fundamentals/
http://habrahabr.ru/post/118782/
http://ruseller.com/lessons.php?rub=32&id=1760
http://net.tutsplus.com/tutorials/javascript-ajax/build-a-contacts-manager-using-backbone-js-part-1/
http://cssmag.ru/blog/2012/08/backbone-js-po-russki/
http://www.sinbadsoft.com/blog/backbone-js-by-example-part-1/
http://jsfiddle.net/nakhli/td6Eg/4/
http://backbonetutorials.com/

EmberJS:
http://en.wikipedia.org/wiki/Ember.js
http://habrahabr.ru/post/149036/
http://ruseller.com/lessons.php?rub=32&id=1719
http://emberjs.ru/
http://apels74.ru/the-ember-js-view-layer-ierarxiya-vidov-delegirovanie-sobyitij.html
https://www.openshift.com/blogs/day-19-ember-the-missing-emberjs-tutorial
http://selleo.com/blog/technologies/building-single-page-web-applications-with-ruby-on-rails/5/

Chapter 4 - Simple App EmberJS
http://todomvc.com/
https://github.com/rhomobile/rho-samples
http://docs.rhomobile.com/guide/creating_a_project
http://www.embersandbox.com/#/js

EmberJS Apps:
https://gist.github.com/machty/5647589
https://github.com/shekhargulati/day19-emberjs-demo
https://github.com/shekhargulati/day19-emberjs-demo.git
http://jsbin.com/OkONoCEz/1/edit
https://github.com/emberjsbook
https://twitter.com/emberbook
https://dl.dropboxusercontent.com/u/4695780/ember_infographics.png
https://github.com/luan/lodos
https://github.com/luan/lodos.git
http://lodos.herokuapp.com/
http://blog.sensible.io/2013/05/23/how-to-write-a-login-form.html
http://jsbin.com/izijal/9/edit
http://emberjs.jsbin.com/iVucEFe/1/edit
